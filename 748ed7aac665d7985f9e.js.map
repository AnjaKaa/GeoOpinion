{"version":3,"sources":["webpack:///748ed7aac665d7985f9e.js","webpack:///webpack/bootstrap 748ed7aac665d7985f9e","webpack:///./~/babel-runtime/core-js/json/stringify.js","webpack:///./src/index.js","webpack:///./~/core-js/library/fn/json/stringify.js","webpack:///./~/core-js/library/modules/_core.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","default","init","createOpinion","coords","inputPlace","inputName","inputOpinion","currentAddress","myMap","balloon","_balloon","_data","properties","console","log","itNewPlacemark","result","some","resultItem","address","newOpinion","currentCoords","place","opinion","date","getCurrentDateTime","push","localStorage","setItem","_stringify2","myPlacemark","createPlacemark","geoObjects","add","clusterer","placeMarks","length","set","getContentBalloon","listOpinionForAddress","innerHTML","getListOpinionForAddress","alert","element","ymaps","Placemark","iconCaption","balloonContentHeader","balloonContentBody","balloonPlace","balloonDate","balloonOpinion","balloonCoords","balloonLayout","BalloonLayout","balloonContentLayout","BalloonContentLayout","getAddress","geocode","then","res","Country","AddressLine","htmlText","content","filter","forEach","dt","Date","year","getFullYear","month","getMonth","day","getDate","hours","getHours","min","getMinutes","sec","getSeconds","Map","center","zoom","controls","searchControlProvider","templateLayoutFactory","createClass","BalloonContentLayoutEmpty","customItemContentLayout","Clusterer","clusterDisableClickZoom","clusterOpenBalloonOnClick","clusterBalloonContentLayout","clusterBalloonItemContentLayout","clusterBalloonPanelMaxMapArea","clusterBalloonContentLayoutWidth","clusterBalloonContentLayoutHeight","clusterBalloonPagerSize","placeMarksAddress","indexOf","events","e","isOpen","close","open","contentHeader","contentBody","layout","contentLayout","map","addEventListener","target","id","innerText","_stringify","obj","getItem","JSON","parse","ready","core","$JSON","stringify","it","apply","arguments","version","__e"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA4BAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAK,EAAA,SAAAK,GAA2C,MAAAA,IAG3CV,EAAAW,EAAA,SAAAR,EAAAS,EAAAC,GACAb,EAAAc,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAb,EAAAoB,EAAA,SAAAhB,GACA,GAAAS,GAAAT,KAAAiB,WACA,WAA2B,MAAAjB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAW,EAAAE,EAAA,IAAAA,GACAA,GAIAb,EAAAc,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDvB,EAAA0B,EAAA,GAGA1B,IAAA2B,EAAA,KDMM,SAAUvB,EAAQD,EAASH,GEtEjCI,EAAAD,SAAkByB,QAAA5B,EAAA,GAAAqB,YAAA,IF4EZ,SAAUjB,EAAQD,EAASH,GAEjC,YGpEA,SAAS6B,KAgJL,QAASC,GAAcC,GACnB,GAAKC,WAAWtB,OAAQuB,UAAUvB,OAAQwB,aAAaxB,MAEhD,CACiB,IAAhByB,IACAA,EAAeC,EAAMC,QAAQC,SAASC,MAAMC,WAAWrB,IAAI,yBAG/DsB,QAAQC,IAAI,QAASP,EAErB,IAAIQ,IAAe,CAEfC,GAAOC,KAAK,SAACC,GACb,MAAOA,GAAWC,SAAWZ,KAE7BM,QAAQC,IAAI,4BAA4BP,GACxCQ,GAAiB,GAEjBF,QAAQC,IAAI,wBAGhB,IAAIM,IACAjB,OAAQkB,EACRF,QAASZ,EACTe,MAAOlB,WAAWtB,MAClBE,KAAMqB,UAAUvB,MAChByC,QAASjB,aAAaxB,MACtB0C,KAAMC,IAMV,IAJAT,EAAOU,KAAKN,GAEZO,aAAaC,QAAQ,mBAAmB,EAAAC,EAAA7B,SAAegB,IAEnDD,EAAgB,CAChB,GAAIe,GAAaC,EAAgBX,EAGjCZ,GAAMwB,WAAWC,IAAIH,GAErBI,EAAUD,IAAIH,GACdK,EAAWT,KAAKI,OAIhB,KAAK,GAAIrD,GAAE,EAAGA,EAAE0D,EAAWC,OAAQ3D,IAC3B0D,EAAW1D,GAAGmC,WAAWrB,IAAI,yBAAyBgB,GACtD4B,EAAW1D,GAAGmC,WAAWyB,IAAI,qBAAsBC,EAAkB/B,GAOjF,OAHAgC,uBAAsBC,UAAUC,EAAyBlC,GACzDM,QAAQC,IAAI,4BAA8BP,GAEnCuB,EAnDPY,MAAM,kDAwDd,QAASX,GAAgBY,GAgBrB,MAfiB,IAAIC,OAAMC,UAAUF,EAAQxC,QACzC2C,YAAa,GACbC,qBAAsBJ,EAAQxB,QAC9B6B,mBAAoBV,EAAkBK,EAAQxB,SAC9C8B,aAAcN,EAAQrB,MACtB4B,YAAaP,EAAQnB,KACrB2B,eAAgBR,EAAQpB,QACxB6B,cAAeT,EAAQxC,SAGnBkD,cAAeC,EACfC,qBAAsBC,IAQlC,QAASC,GAAWtD,GAEhB,MAAOyC,OAAMc,QAAQvD,GAAQwD,KAAK,SAAUC,GACxC,MAAOA,GAAI5B,WAAWzC,IAAI,GAAGqB,WAAWrB,IAAI,oDACvCsE,QAAQC,cAMrB,QAASxB,GAAkBnB,GACvB,GAAI4C,GAAS,EAWb,OATAA,IAAU,oCAAoCtB,EAAyBtB,IAAU,oBAAoB,SACrG4C,GAAU,SACVA,GAAU,8CACVA,GAAU,yEACVA,GAAU,+EACVA,GAAU,oGACVA,GAAU,yDACVA,GAAU,UAMd,QAAStB,GAAyBtB,GAC9B,GAAI6C,GAAQ,EAcZ,OAXAhD,GACGiD,OAAO,SAAC/C,GACL,MAAOA,GAAWC,SAASA,IAE9B+C,QAAU,SAAChD,GACR8C,GAAS,MAAM9C,EAAWlC,KAAK,QAC/BgF,GAAS9C,EAAWI,MAAM,IAC1B0C,GAAS9C,EAAWM,KAAK,OACzBwC,GAAS9C,EAAWK,QAAQ,SAG3ByC,EAGX,QAASvC,KACL,GAAI0C,GAAG,GAAIC,MAEPC,EAAOF,EAAGG,cAEVC,EAAQJ,EAAGK,WAAW,CAEtBD,GAAM,KACNA,EAAQ,IAAIA,EAGhB,IAAIE,GAAMN,EAAGO,SAETD,GAAI,KACJA,EAAM,IAAIA,EAEd,IAAIE,GAAQR,EAAGS,UAEXD,GAAM,KACNA,EAAQ,IAAIA,EAGhB,IAAIE,GAAMV,EAAGW,YAETD,GAAI,KACJA,EAAM,IAAIA,EAEd,IAAIE,GAAMZ,EAAGa,YAMb,OAJID,GAAI,KACJA,EAAI,IAAIA,GAGLV,EAAK,IAAIE,EAAM,IAAIE,EAAI,IAAIE,EAAM,IAAIE,EAAI,IAAIE,EA1SxD,GAAIvE,GAAQ,GAAIoC,OAAMqC,IAAI,OAElBC,QAAS,UAAW,WACpBC,KAAM,GACNC,cAGAC,sBAAuB,kBAK3B/B,EAAgBV,MAAM0C,sBAAsBC,YAC5C,yJAKA/B,EAAuBZ,MAAM0C,sBAAsBC,YACnD,oKAOAC,EAA4B5C,MAAM0C,sBAAsBC,YACxD,gIAQAE,EAA0B7C,MAAM0C,sBAAsBC,YAEtD,6SAQArD,EAAY,GAAIU,OAAM8C,WACtBC,yBAAyB,EACzBC,2BAA2B,EAE3BC,4BAA6B,0BAE7BC,gCAAiCL,EAGjCM,8BAA+B,EAE/BC,iCAAkC,IAClCC,kCAAmC,IAEnCC,wBAAyB,KAW7B,WAII,IAAK,GAFDC,MAEK1H,EAAE,EAAEA,EAAEuC,EAAOoB,OAAO3D,IACzB,IAAmD,GAA/C0H,EAAkBC,QAAQpF,EAAOvC,GAAG0C,SAAc,CAClD,GAAIW,GAAaC,EAAgBf,EAAOvC,GAExC+B,GAAMwB,WAAWC,IAAIH,GACrBqE,EAAkBzE,KAAKV,EAAOvC,GAAG0C,SACjCgB,EAAWT,KAAKI,GAGxBI,EAAUD,IAAIE,GACd3B,EAAMwB,WAAWC,IAAIC,MAMzB1B,EAAM6F,OAAOpE,IAAI,QAAS,SAAUqE,GAChC,GAAK9F,EAAMC,QAAQ8F,SAkBf/F,EAAMC,QAAQ+F,YAlBW,CACzB,GAAIrG,GAASmG,EAAE/G,IAAI,SAEnBkE,GAAWtD,GACVwD,KAAK,SAACC,GACHrD,EAAeqD,EACfvC,EAAclB,EACdK,EAAMC,QAAQgG,KAAKtG,GAEXuG,cAAe9C,EACf+C,YAAarE,EAAkB/B,KAG/BqG,OAAQtD,EACRuD,cAAerB,SASnCsB,IAAIC,iBAAiB,QAAS,SAACT,GAO3B,GANiB,aAAbA,EAAEU,OAAOC,IACT/G,IAEa,SAAboG,EAAEU,OAAOC,IACTzG,EAAMC,QAAQ+F,QAED,iBAAbF,EAAEU,OAAOC,GACT,IAAK,GAAIxI,GAAE,EAAGA,EAAE0D,EAAWC,OAAQ3D,IAC3B0D,EAAW1D,GAAGmC,WAAWrB,IAAK,yBAAyB+G,EAAEU,OAAOE,WAI/D1G,EAAMC,QAAQgG,KAAKtE,EAAW1D,GAAGmC,WAAWrB,IAAK,kBAE9CmH,cAAevE,EAAW1D,GAAGmC,WAAWrB,IAAK,wBAC7CoH,YAAarE,EAAkBgE,EAAEU,OAAOE,aAGxCN,OAAQtD,EACRuD,cAAerB,MHhEvC,GAAI2B,GAAa/I,EAAoB,GAEjCyD,EAEJ,SAAgCuF,GAAO,MAAOA,IAAOA,EAAI3H,WAAa2H,GAAQpH,QAASoH,IAF9CD,GGnFrCnG,IAEAW,cAAa0F,QAAQ,qBACrBrG,EAAOsG,KAAKC,MAAM5F,aAAa0F,QAAQ,oBAE3C,IACIhG,GADAd,EAAe,GAEf4B,IAEJS,OAAM4E,MAAMvH,IHkWN,SAAUzB,EAAQD,EAASH,GI3WjC,GAAAqJ,GAAArJ,EAAA,GACAsJ,EAAAD,EAAAH,OAAAG,EAAAH,MAAuCK,UAAAL,KAAAK,WACvCnJ,GAAAD,QAAA,SAAAqJ,GACA,MAAAF,GAAAC,UAAAE,MAAAH,EAAAI,aJkXM,SAAUtJ,EAAQD,GKrXxB,GAAAkJ,GAAAjJ,EAAAD,SAA6BwJ,QAAA,QAC7B,iBAAAC,WAAAP","file":"748ed7aac665d7985f9e.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(2), __esModule: true };\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _stringify = __webpack_require__(0);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar result = [];\n\nif (localStorage.getItem('myPlacemarkList')) {\n    result = JSON.parse(localStorage.getItem('myPlacemarkList'));\n}\nvar currentAddress = '',\n    currentCoords,\n    placeMarks = [];\n\nymaps.ready(init);\nfunction init() {\n    var myMap = new ymaps.Map('map', {\n        center: [55.753994, 37.622093],\n        zoom: 16,\n        controls: []\n    }, {\n        searchControlProvider: 'yandex#search'\n    });\n\n    // шаблон balloon\n    var BalloonLayout = ymaps.templateLayoutFactory.createClass('<div class=\"templateBalloon\">' + '<a class=\"close\" id=\"close\" href=\"#\">&times;</a>' + '$[[options.contentLayout observeSize maxWidth=310  maxHeight=500]]' + '</div>');\n\n    var BalloonContentLayout = ymaps.templateLayoutFactory.createClass('<div class=\"templateBalloonHeader\">' + '<b>{{properties.balloonContentHeader}}</b><br />' + '</div>' + '<div class=\"templateBalloonBody\">' + '$[properties.balloonContentBody]' + '</div>');\n    var BalloonContentLayoutEmpty = ymaps.templateLayoutFactory.createClass('<div class=\"templateBalloonHeader\">' + '<b>{{contentHeader}}</b><br />' + '</div>' + '<div class=\"templateBalloonBody\">' + '$[contentBody]' + '</div>');\n    // Создаем собственный макет с информацией о выбранном геообъекте.\n    var customItemContentLayout = ymaps.templateLayoutFactory.createClass(\n    // Флаг \"raw\" означает, что данные вставляют \"как есть\" без экранирования html.\n    '<h2 class=ballon_place>{{ properties.balloonPlace|raw }}</h2>' + '<div class=ballon_address ><a href=\"#\" id=\"linkPlacemark\">' + '{{properties.balloonContentHeader|raw }}' + '</a></div>' + '<div class=ballon_opinion>{{ properties.balloonOpinion|raw }}</div>' + '<div class=ballon_date>{{ properties.balloonDate|raw }}</div>');\n\n    var clusterer = new ymaps.Clusterer({\n        clusterDisableClickZoom: true,\n        clusterOpenBalloonOnClick: true,\n        // Устанавливаем стандартный макет балуна кластера \"Карусель\".\n        clusterBalloonContentLayout: 'cluster#balloonCarousel',\n        // Устанавливаем собственный макет.\n        clusterBalloonItemContentLayout: customItemContentLayout,\n        // Устанавливаем режим открытия балуна. \n        // В данном примере балун никогда не будет открываться в режиме панели.\n        clusterBalloonPanelMaxMapArea: 0,\n        // Устанавливаем размеры макета контента балуна (в пикселях).\n        clusterBalloonContentLayoutWidth: 200,\n        clusterBalloonContentLayoutHeight: 130,\n        // Устанавливаем максимальное количество элементов в нижней панели на одной странице\n        clusterBalloonPagerSize: 5\n        // Настройка внешего вида нижней панели.\n        // Режим marker рекомендуется использовать с небольшим количеством элементов.\n        // clusterBalloonPagerType: 'marker',\n        // Можно отключить зацикливание списка при навигации при помощи боковых стрелок.\n        // clusterBalloonCycling: false,\n        // Можно отключить отображение меню навигации.\n        // clusterBalloonPagerVisible: false\n    });\n\n    // загружаем сохранённые метки\n    function loadStorage() {\n\n        var placeMarksAddress = [];\n\n        for (var i = 0; i < result.length; i++) {\n            if (placeMarksAddress.indexOf(result[i].address) == -1) {\n                var myPlacemark = createPlacemark(result[i]);\n\n                myMap.geoObjects.add(myPlacemark);\n                placeMarksAddress.push(result[i].address);\n                placeMarks.push(myPlacemark);\n            }\n        }\n        clusterer.add(placeMarks);\n        myMap.geoObjects.add(clusterer);\n    }\n\n    loadStorage();\n\n    // Слушаем клик на карте.\n    myMap.events.add('click', function (e) {\n        if (!myMap.balloon.isOpen()) {\n            var coords = e.get('coords');\n\n            getAddress(coords).then(function (res) {\n                currentAddress = res;\n                currentCoords = coords;\n                myMap.balloon.open(coords, {\n                    contentHeader: res,\n                    contentBody: getContentBalloon(currentAddress)\n                }, {\n                    layout: BalloonLayout,\n                    contentLayout: BalloonContentLayoutEmpty\n                });\n            });\n        } else {\n            myMap.balloon.close();\n        }\n    });\n\n    // слушаем клики на карте\n    map.addEventListener('click', function (e) {\n        if (e.target.id == 'addbutton') {\n            createOpinion();\n        }\n        if (e.target.id == 'close') {\n            myMap.balloon.close();\n        }\n        if (e.target.id == 'linkPlacemark') {\n            for (var i = 0; i < placeMarks.length; i++) {\n                if (placeMarks[i].properties.get('balloonContentHeader') == e.target.innerText) {\n\n                    //console.log('центрировать метку по адресу'+placeMarks[i].properties.get('balloonContentHeader'));\n                    // placeMarks[i].balloon.open();\n                    myMap.balloon.open(placeMarks[i].properties.get('balloonCoords'), {\n                        contentHeader: placeMarks[i].properties.get('balloonContentHeader'),\n                        contentBody: getContentBalloon(e.target.innerText)\n                    }, {\n                        layout: BalloonLayout,\n                        contentLayout: BalloonContentLayoutEmpty\n                    });\n                }\n            }\n        }\n    });\n\n    // Создание нового отзыва\n    function createOpinion(coords) {\n        if (!inputPlace.value || !inputName.value || !inputOpinion.value) {\n            alert('Не все поля заполнены! Отзыв не будет добавлен');\n        } else {\n            if (currentAddress == '') {\n                currentAddress = myMap.balloon._balloon._data.properties.get('balloonContentHeader');\n            }\n\n            console.log('Адрес', currentAddress);\n\n            var itNewPlacemark = true;\n\n            if (result.some(function (resultItem) {\n                return resultItem.address == currentAddress;\n            })) {\n                console.log('есть уже метка по адресу ' + currentAddress);\n                itNewPlacemark = false;\n            } else {\n                console.log('добавляем новую метку');\n            }\n\n            var newOpinion = {\n                coords: currentCoords,\n                address: currentAddress,\n                place: inputPlace.value,\n                name: inputName.value,\n                opinion: inputOpinion.value,\n                date: getCurrentDateTime()\n            };\n            result.push(newOpinion);\n\n            localStorage.setItem('myPlacemarkList', (0, _stringify2.default)(result));\n\n            if (itNewPlacemark) {\n                var myPlacemark = createPlacemark(newOpinion);\n\n                // добавим новую метку на карту\n                myMap.geoObjects.add(myPlacemark);\n                // добавим новую метку в кластер\n                clusterer.add(myPlacemark);\n                placeMarks.push(myPlacemark);\n            } else {\n                // добавим новый отзыв в список отзываов по адресу\n\n                for (var i = 0; i < placeMarks.length; i++) {\n                    if (placeMarks[i].properties.get('balloonContentHeader') == currentAddress) {\n                        placeMarks[i].properties.set('balloonContentBody', getContentBalloon(currentAddress));\n                    }\n                }\n            }\n            listOpinionForAddress.innerHTML = getListOpinionForAddress(currentAddress);\n            console.log('отзыв добавлен по адресу ' + currentAddress);\n\n            return myPlacemark;\n        }\n    }\n\n    // Создание новой метки\n    function createPlacemark(element) {\n        var myPlacemark = new ymaps.Placemark(element.coords, {\n            iconCaption: '',\n            balloonContentHeader: element.address,\n            balloonContentBody: getContentBalloon(element.address),\n            balloonPlace: element.place,\n            balloonDate: element.date,\n            balloonOpinion: element.opinion,\n            balloonCoords: element.coords\n        }, {\n            balloonLayout: BalloonLayout,\n            balloonContentLayout: BalloonContentLayout\n        });\n\n        return myPlacemark;\n    }\n\n    // Определяем адрес по координатам (обратное геокодирование).\n    function getAddress(coords) {\n\n        return ymaps.geocode(coords).then(function (res) {\n            return res.geoObjects.get(0).properties.get('metaDataProperty.GeocoderMetaData.AddressDetails').Country.AddressLine;\n        });\n    }\n\n    // получим содержимое формы ввода отзыва\n    function getContentBalloon(address) {\n        var htmlText = '';\n\n        htmlText += '<div id=\"listOpinionForAddress\">' + (getListOpinionForAddress(address) || 'Отзывов пока нет') + '</div>';\n        htmlText += '<form>';\n        htmlText += '<h4 style=\"color: #f6856e;\"> ВАШ ОТЗЫВ</h4>';\n        htmlText += '<input type=\"text\" class=\"input\" id=\"inputName\" placeholder=\"Имя\"><br>';\n        htmlText += '<input type=\"text\" class=\"input\" id=\"inputPlace\" placeholder=\"Компания\"><br>';\n        htmlText += '<textarea class=\"input\" placeholder=\"Ваши впечатления\" id=\"inputOpinion\" rows=\"6\"></textarea><br>';\n        htmlText += '<button id=\\'addbutton\\' type=\\'button\\'>Добавить</button>';\n        htmlText += '</form>';\n\n        return htmlText;\n    }\n\n    // список отзывов по адресу\n    function getListOpinionForAddress(address) {\n        var content = '';\n\n        // for (var i=0; i<result.length;i++) \n        result.filter(function (resultItem) {\n            return resultItem.address == address;\n        }).forEach(function (resultItem) {\n            content += '<b>' + resultItem.name + '</b> ';\n            content += resultItem.place + ' ';\n            content += resultItem.date + '<br>';\n            content += resultItem.opinion + '<br>';\n        });\n\n        return content;\n    }\n\n    function getCurrentDateTime() {\n        var dt = new Date();\n\n        var year = dt.getFullYear();\n\n        var month = dt.getMonth() + 1;\n\n        if (month < 10) {\n            month = '0' + month;\n        }\n\n        var day = dt.getDate();\n\n        if (day < 10) {\n            day = '0' + day;\n        }\n        var hours = dt.getHours();\n\n        if (hours < 10) {\n            hours = '0' + hours;\n        }\n\n        var min = dt.getMinutes();\n\n        if (min < 10) {\n            min = '0' + min;\n        }\n        var sec = dt.getSeconds();\n\n        if (sec < 10) {\n            sec = '0' + sec;\n        }\n\n        return year + '.' + month + '.' + day + ' ' + hours + ':' + min + ':' + sec;\n    }\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar core  = __webpack_require__(3)\n  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\nmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 748ed7aac665d7985f9e.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 748ed7aac665d7985f9e","module.exports = { \"default\": require(\"core-js/library/fn/json/stringify\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/json/stringify.js\n// module id = 0\n// module chunks = 0","var result=[];\r\n\r\nif (localStorage.getItem('myPlacemarkList')) {\r\n    result=JSON.parse(localStorage.getItem('myPlacemarkList'));\r\n}\r\nvar currentAddress='',\r\n    currentCoords,\r\n    placeMarks=[];\r\n\r\nymaps.ready(init);\r\nfunction init() {\r\n    var myMap = new ymaps.Map('map', \r\n        {\r\n            center: [55.753994, 37.622093],\r\n            zoom: 16,\r\n            controls: []\r\n        }, \r\n        {\r\n            searchControlProvider: 'yandex#search'\r\n        }\r\n      );\r\n\r\n// шаблон balloon\r\n    var BalloonLayout = ymaps.templateLayoutFactory.createClass(\r\n        '<div class=\"templateBalloon\">' +\r\n        '<a class=\"close\" id=\"close\" href=\"#\">&times;</a>' +\r\n        '$[[options.contentLayout observeSize maxWidth=310  maxHeight=500]]' +\r\n        '</div>');\r\n\r\n    var BalloonContentLayout = ymaps.templateLayoutFactory.createClass(\r\n        '<div class=\"templateBalloonHeader\">' +\r\n            '<b>{{properties.balloonContentHeader}}</b><br />' +\r\n        '</div>'+\r\n        '<div class=\"templateBalloonBody\">'+\r\n            '$[properties.balloonContentBody]'+\r\n        '</div>'\r\n    );\r\n    var BalloonContentLayoutEmpty = ymaps.templateLayoutFactory.createClass(\r\n        '<div class=\"templateBalloonHeader\">' +\r\n            '<b>{{contentHeader}}</b><br />' +\r\n        '</div>'+\r\n        '<div class=\"templateBalloonBody\">'+\r\n            '$[contentBody]'+\r\n        '</div>'\r\n    );\r\n// Создаем собственный макет с информацией о выбранном геообъекте.\r\n    var customItemContentLayout = ymaps.templateLayoutFactory.createClass(\r\n        // Флаг \"raw\" означает, что данные вставляют \"как есть\" без экранирования html.\r\n        '<h2 class=ballon_place>{{ properties.balloonPlace|raw }}</h2>' +\r\n            '<div class=ballon_address ><a href=\"#\" id=\"linkPlacemark\">'+\r\n            '{{properties.balloonContentHeader|raw }}'+\r\n            '</a></div>' +\r\n            '<div class=ballon_opinion>{{ properties.balloonOpinion|raw }}</div>'+\r\n            '<div class=ballon_date>{{ properties.balloonDate|raw }}</div>'\r\n    );\r\n\r\n    var clusterer = new ymaps.Clusterer({\r\n        clusterDisableClickZoom: true,\r\n        clusterOpenBalloonOnClick: true,\r\n        // Устанавливаем стандартный макет балуна кластера \"Карусель\".\r\n        clusterBalloonContentLayout: 'cluster#balloonCarousel',\r\n        // Устанавливаем собственный макет.\r\n        clusterBalloonItemContentLayout: customItemContentLayout,\r\n        // Устанавливаем режим открытия балуна. \r\n        // В данном примере балун никогда не будет открываться в режиме панели.\r\n        clusterBalloonPanelMaxMapArea: 0,\r\n        // Устанавливаем размеры макета контента балуна (в пикселях).\r\n        clusterBalloonContentLayoutWidth: 200,\r\n        clusterBalloonContentLayoutHeight: 130,\r\n        // Устанавливаем максимальное количество элементов в нижней панели на одной странице\r\n        clusterBalloonPagerSize: 5\r\n        // Настройка внешего вида нижней панели.\r\n        // Режим marker рекомендуется использовать с небольшим количеством элементов.\r\n        // clusterBalloonPagerType: 'marker',\r\n        // Можно отключить зацикливание списка при навигации при помощи боковых стрелок.\r\n        // clusterBalloonCycling: false,\r\n        // Можно отключить отображение меню навигации.\r\n        // clusterBalloonPagerVisible: false\r\n    });\r\n\r\n    // загружаем сохранённые метки\r\n    function loadStorage() {\r\n \r\n        var placeMarksAddress=[];\r\n\r\n        for (var i=0;i<result.length;i++) {       \r\n            if (placeMarksAddress.indexOf(result[i].address)==-1) {\r\n                var myPlacemark= createPlacemark(result[i]);\r\n\r\n                myMap.geoObjects.add(myPlacemark);\r\n                placeMarksAddress.push(result[i].address);\r\n                placeMarks.push(myPlacemark);\r\n            }\r\n        }\r\n        clusterer.add(placeMarks);\r\n        myMap.geoObjects.add(clusterer);\r\n    }\r\n\r\n    loadStorage();\r\n\r\n// Слушаем клик на карте.\r\n    myMap.events.add('click', function (e) {\r\n        if (!myMap.balloon.isOpen()) {\r\n            var coords = e.get('coords');\r\n\r\n            getAddress(coords)\r\n            .then((res)=>{\r\n                currentAddress=res;\r\n                currentCoords=coords;\r\n                myMap.balloon.open(coords, \r\n                    {\r\n                        contentHeader: res,\r\n                        contentBody: getContentBalloon(currentAddress)\r\n                    },\r\n                    {\r\n                        layout: BalloonLayout,\r\n                        contentLayout: BalloonContentLayoutEmpty\r\n                    }); \r\n            })\r\n        } else {\r\n            myMap.balloon.close();\r\n        }\r\n    });\r\n\r\n    // слушаем клики на карте\r\n    map.addEventListener('click', (e) => {\r\n        if (e.target.id=='addbutton') {\r\n            createOpinion();\r\n        }\r\n        if (e.target.id=='close') {\r\n            myMap.balloon.close();\r\n        }\r\n        if (e.target.id=='linkPlacemark') {\r\n            for (var i=0; i<placeMarks.length; i++) { \r\n                if (placeMarks[i].properties.get ('balloonContentHeader')==e.target.innerText) {\r\n              \r\n                    //console.log('центрировать метку по адресу'+placeMarks[i].properties.get('balloonContentHeader'));\r\n                    // placeMarks[i].balloon.open();\r\n                     myMap.balloon.open(placeMarks[i].properties.get ('balloonCoords'), \r\n                    {\r\n                        contentHeader: placeMarks[i].properties.get ('balloonContentHeader'),\r\n                        contentBody: getContentBalloon(e.target.innerText)\r\n                    },\r\n                    {\r\n                        layout: BalloonLayout,\r\n                        contentLayout: BalloonContentLayoutEmpty\r\n                    }); \r\n                }\r\n            } \r\n            \r\n        }\r\n    });\r\n  \r\n   // Создание нового отзыва\r\n    function createOpinion(coords) {\r\n        if (!inputPlace.value||!inputName.value||!inputOpinion.value) {\r\n            alert('Не все поля заполнены! Отзыв не будет добавлен')\r\n        } else { \r\n            if (currentAddress=='') {\r\n                currentAddress=myMap.balloon._balloon._data.properties.get('balloonContentHeader');\r\n            }\r\n\r\n            console.log('Адрес', currentAddress);\r\n\r\n            var itNewPlacemark=true;\r\n\r\n            if (result.some((resultItem)=> {\r\n                return resultItem.address == currentAddress \r\n            })) { \r\n                console.log('есть уже метка по адресу '+currentAddress);\r\n                itNewPlacemark = false;\r\n            } else { \r\n                console.log('добавляем новую метку');\r\n            }\r\n\r\n            var newOpinion = {\r\n                coords: currentCoords,\r\n                address: currentAddress,\r\n                place: inputPlace.value,\r\n                name: inputName.value,\r\n                opinion: inputOpinion.value,\r\n                date: getCurrentDateTime()\r\n            };\r\n            result.push(newOpinion);\r\n\r\n            localStorage.setItem('myPlacemarkList', JSON.stringify(result)); \r\n                \r\n            if (itNewPlacemark) {\r\n                var myPlacemark= createPlacemark(newOpinion);\r\n\r\n                // добавим новую метку на карту\r\n                myMap.geoObjects.add(myPlacemark); \r\n                // добавим новую метку в кластер\r\n                clusterer.add(myPlacemark);\r\n                placeMarks.push(myPlacemark)\r\n            } else {\r\n                // добавим новый отзыв в список отзываов по адресу\r\n\r\n                for (var i=0; i<placeMarks.length; i++) {                   \r\n                    if (placeMarks[i].properties.get('balloonContentHeader')==currentAddress) {\r\n                        placeMarks[i].properties.set('balloonContentBody', getContentBalloon(currentAddress));\r\n                    }\r\n                }\r\n            }                     \r\n            listOpinionForAddress.innerHTML=getListOpinionForAddress(currentAddress);        \r\n            console.log('отзыв добавлен по адресу ' + currentAddress);\r\n\r\n            return myPlacemark;\r\n        }\r\n    }\r\n\r\n    // Создание новой метки\r\n    function createPlacemark(element) {\r\n        var myPlacemark= new ymaps.Placemark(element.coords, {\r\n            iconCaption: '',\r\n            balloonContentHeader: element.address,\r\n            balloonContentBody: getContentBalloon(element.address),\r\n            balloonPlace: element.place,\r\n            balloonDate: element.date,\r\n            balloonOpinion: element.opinion,\r\n            balloonCoords: element.coords\r\n        },\r\n            {\r\n                balloonLayout: BalloonLayout,\r\n                balloonContentLayout: BalloonContentLayout\r\n            }\r\n        );\r\n\r\n        return myPlacemark;\r\n    }\r\n\r\n// Определяем адрес по координатам (обратное геокодирование).\r\n    function getAddress(coords) { \r\n\r\n        return ymaps.geocode(coords).then(function (res) {\r\n            return res.geoObjects.get(0).properties.get('metaDataProperty.GeocoderMetaData.AddressDetails')\r\n                .Country.AddressLine;       \r\n             \r\n        });\r\n    }\r\n\r\n    // получим содержимое формы ввода отзыва\r\n    function getContentBalloon(address) {\r\n        var htmlText='';\r\n\r\n        htmlText+='<div id=\"listOpinionForAddress\">'+(getListOpinionForAddress(address)||'Отзывов пока нет')+'</div>';\r\n        htmlText+='<form>';\r\n        htmlText+='<h4 style=\"color: #f6856e;\"> ВАШ ОТЗЫВ</h4>';\r\n        htmlText+='<input type=\"text\" class=\"input\" id=\"inputName\" placeholder=\"Имя\"><br>';\r\n        htmlText+='<input type=\"text\" class=\"input\" id=\"inputPlace\" placeholder=\"Компания\"><br>';  \r\n        htmlText+='<textarea class=\"input\" placeholder=\"Ваши впечатления\" id=\"inputOpinion\" rows=\"6\"></textarea><br>';\r\n        htmlText+='<button id=\\'addbutton\\' type=\\'button\\'>Добавить</button>';\r\n        htmlText+='</form>';\r\n        \r\n        return htmlText;\r\n    }\r\n\r\n    // список отзывов по адресу\r\n    function getListOpinionForAddress(address) {\r\n        var content='';\r\n\r\n        // for (var i=0; i<result.length;i++) \r\n        result\r\n          .filter((resultItem)=> {\r\n              return resultItem.address==address\r\n          })\r\n          .forEach ( (resultItem)=>{\r\n              content+='<b>'+resultItem.name+'</b> '; \r\n              content+=resultItem.place+' '; \r\n              content+=resultItem.date+'<br>'; \r\n              content+=resultItem.opinion+'<br>'; \r\n          });\r\n\r\n        return content;\r\n    }\r\n\r\n    function getCurrentDateTime() {\r\n        var dt=new Date();\r\n\r\n        var year = dt.getFullYear();\r\n\r\n        var month = dt.getMonth()+1;\r\n\r\n        if (month<10) { \r\n            month = '0'+month;\r\n        }\r\n\r\n        var day = dt.getDate();\r\n\r\n        if (day<10) {\r\n            day = '0'+day;\r\n        }   \r\n        var hours = dt.getHours();\r\n\r\n        if (hours<10) { \r\n            hours = '0'+hours; \r\n        }\r\n\r\n        var min = dt.getMinutes();\r\n\r\n        if (min<10) {\r\n            min = '0'+min;\r\n        }\r\n        var sec = dt.getSeconds();\r\n\r\n        if (sec<10) { \r\n            sec='0'+sec;\r\n        }\r\n\r\n        return year+'.'+month+'.'+day+' '+hours+':'+min+':'+sec;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","var core  = require('../../modules/_core')\n  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\nmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/json/stringify.js\n// module id = 2\n// module chunks = 0","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_core.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}